name: Pipeline de Despliegue FlowTask (CI/CD)

# ------------------------------------------------------------------------------
# CONFIGURACIÓN DEL DISPARADOR (TRIGGER)
# ------------------------------------------------------------------------------
# "on" define cuándo se ejecuta este pipeline.
# En este caso, se ejecuta automáticamente cuando hacemos un "push" (subir cambios)
# o un "pull request" (solicitud de cambios) hacia la rama principal 'main'.
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# ------------------------------------------------------------------------------
# VARIABLES DE ENTORNO GLOBALES
# ------------------------------------------------------------------------------
# Variables disponibles para todo el flujo de trabajo.
env:
  APP_NAME: flow-task # Nombre de la aplicación usado para etiquetar imágenes y carpetas

# ------------------------------------------------------------------------------
# TRABAJOS (JOBS)
# ------------------------------------------------------------------------------
# Un pipeline se compone de uno o más "jobs" que pueden correr en paralelo o secuencia.
jobs:
  build-and-deploy:
    # Nombre legible del trabajo
    name: Construir y Desplegar
    
    # Define la máquina virtual donde correrá este trabajo (Ubuntu Linux)
    runs-on: ubuntu-latest
    
    # Condición: Solo ejecutar si la referencia es la rama 'main' (evita despliegues desde ramas de prueba)
    if: github.ref == 'refs/heads/main'

    # PASOS (STEPS)
    # Lista de tareas secuenciales que ejecuta el trabajo
    steps:
      
      # 1. Obtener el código fuente
      # Usa una acción oficial de GitHub para descargar el código del repositorio a la máquina virtual.
      - name: Descargar código fuente (Checkout)
        uses: actions/checkout@v4

      # 2. Iniciar sesión en Docker Hub
      # Necesario para poder subir (push) la imagen privada que vamos a construir.
      # Usa secretos configurados en GitHub para no exponer contraseñas en el código.
      - name: Iniciar sesión en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 3. Construir y subir imagen Docker
      # Crea la imagen "paquete" con todo el código y librerías, y la sube a la nube (Docker Hub).
      # Esto asegura que lo que probamos es exactamente lo que desplegamos.
      - name: Construir y subir imagen Docker
        uses: docker/build-push-action@v5
        with:
          context: . # Usa el directorio actual como contexto
          push: true # Sube la imagen al registro después de construirla
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ env.APP_NAME }}:latest # Etiqueta la imagen

      # 4. Desplegar en Servidor VPS (SSH)
      # Se conecta al servidor remoto usando SSH y ejecuta comandos para actualizar la aplicación.
      - name: Desplegar en Servidor VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VPS_HOST }}       # Dirección IP del servidor
          username: ${{ secrets.VPS_USERNAME }} # Usuario SSH (ej. root)
          key: ${{ secrets.VPS_SSH_KEY }}     # Clave privada SSH
          port: ${{ secrets.VPS_PORT }}       # Puerto SSH (por defecto 22)
          script: |
            # --- INICIO DEL SCRIPT DE DESPLIEGUE EN EL SERVIDOR ---
            
            # 1. Preparar directorio de la aplicación
            # Crea la carpeta si no existe y entra en ella
            mkdir -p /opt/${{ env.APP_NAME }}
            cd /opt/${{ env.APP_NAME }}
            
            # 2. Crear archivo de variables de entorno (.env)
            # Generamos el archivo .env dinámicamente con los secretos de GitHub.
            # Esto es seguro porque el archivo solo vive en el servidor.
            echo "Generando archivo .env..."
            cat > .env << EOF
            DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
            PG_DB_USERNAME=${{ secrets.PG_DB_USERNAME }}
            PG_DB_PASSWORD=${{ secrets.PG_DB_PASSWORD }}
            PG_DB_NAME=${{ secrets.PG_DB_NAME }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
            JWT_ACCESS_EXPIRATION_MINUTES=${{ secrets.JWT_ACCESS_EXPIRATION_MINUTES }}
            JWT_REFRESH_EXPIRATION_DAYS=${{ secrets.JWT_REFRESH_EXPIRATION_DAYS }}
            # Puerto interno de la app
            PORT=3000
            # URL de conexión a la Base de Datos (Requerido por Prisma)
            DATABASE_URL=postgresql://${{ secrets.PG_DB_USERNAME }}:${{ secrets.PG_DB_PASSWORD }}@postgres:5432/${{ secrets.PG_DB_NAME }}?schema=public
            EOF

            # 3. Crear archivo docker-compose.prod.yml
            # Definimos la infraestructura necesaria (App + Base de Datos)
            # Usamos la imagen que acabamos de subir a Docker Hub.
            echo "Generando docker-compose.prod.yml..."
            cat > docker-compose.prod.yml << 'DOCKERCOMPOSE'
            version: '3.8'

            services:
              app:
                container_name: flow-task-app
                # Usa la imagen más reciente
                image: ${{ secrets.DOCKER_USERNAME }}/${{ env.APP_NAME }}:latest
                restart: always
                ports:
                  - "3000:3000" # Expone el puerto 3000
                env_file: .env # Lee las variables generadas arriba
                depends_on:
                  - postgres
                networks:
                  - app-network

              postgres:
                image: postgres:15-alpine
                container_name: flowtask_prod_db
                restart: always
                env_file: .env # Lee variables de BD (USER, PASSWORD, DB)
                environment:
                  POSTGRES_USER: ${{ secrets.PG_DB_USERNAME }}
                  POSTGRES_PASSWORD: ${{ secrets.PG_DB_PASSWORD }}
                  POSTGRES_DB: ${{ secrets.PG_DB_NAME }}
                volumes:
                  - postgres_data_prod:/var/lib/postgresql/data
                networks:
                  - app-network

            networks:
              app-network:
                driver: bridge

            volumes:
              postgres_data_prod:
            DOCKERCOMPOSE

            # 4. Actualizar contenedores
            # Descarga la nueva imagen y reinicia los servicios
            echo "Desplegando nueva versión..."
            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml down
            docker compose -f docker-compose.prod.yml up -d

            # 5. Esperar a que la base de datos esté lista
            echo "Esperando inicio de servicios..."
            sleep 10

            # 6. Ejecutar migraciones de base de datos
            # Actualiza el esquema de la BD si hubo cambios
            echo "Ejecutando migraciones..."
            docker exec flow-task-app npx prisma migrate deploy

            # 7. Limpieza
            # Elimina imágenes antiguas para liberar espacio en disco
            echo "Limpiando imágenes antiguas..."
            docker image prune -f
